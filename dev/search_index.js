var documenterSearchIndex = {"docs":
[{"location":"api/#API-Documentation","page":"API Documentation","title":"API Documentation","text":"","category":"section"},{"location":"api/#Metatheory","page":"API Documentation","title":"Metatheory","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Modules = [Metatheory]","category":"page"},{"location":"api/#Main.Metatheory.Rule","page":"API Documentation","title":"Main.Metatheory.Rule","text":"mutable struct Rule\n\nStructure representing rewrite rules.\n\n\n\nFields\n\nleft::Any\nright::Any\nexpr::Expr\nmode::Symbol\n\n\n\n\n\n","category":"type"},{"location":"api/#Main.Metatheory.compile_theory-Tuple{Array{Main.Metatheory.Rule,1},Module}","page":"API Documentation","title":"Main.Metatheory.compile_theory","text":"Compile a theory to a closure that does the pattern matching job Returns a RuntimeGeneratedFunction, which does not use eval and is as fast as a regular Julia anonymous function ðŸ”¥\n\n\n\nSignatures\n\ncompile_theory(theory::Array{Main.Metatheory.Rule,1}, mod::Module; __source__) -> RuntimeGeneratedFunctions.RuntimeGeneratedFunction{_A,_B,_C,_D} where _D where _C where _B where _A\n\n\n\n\nMethods\n\ncompile_theory(theory, mod; __source__)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/matchcore_compiler.jl:61.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.@compile_theory-Tuple{Any}","page":"API Documentation","title":"Main.Metatheory.@compile_theory","text":"Compile a theory at runtime to a closure that does the pattern matching job\n\n\n\nSignatures\n\n\n\nMethods\n\n\n\n\n\n","category":"macro"},{"location":"api/#Metatheory.EGraphs","page":"API Documentation","title":"Metatheory.EGraphs","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"CurrentModule = Metatheory\nDocTestSetup  = quote\n    using Metatheory\nend","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Modules = [Metatheory.EGraphs]","category":"page"},{"location":"api/#Main.Metatheory.EGraphs.AbstractAnalysis","page":"API Documentation","title":"Main.Metatheory.EGraphs.AbstractAnalysis","text":"abstract type AbstractAnalysis\n\n\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"api/#Main.Metatheory.EGraphs.EGraph","page":"API Documentation","title":"Main.Metatheory.EGraphs.EGraph","text":"mutable struct EGraph\n\n\n\nFields\n\nU::DataStructures.IntDisjointSets\nequality relation over e-class ids\nM::Dict{Int64,Array{Any,1}}\nH::Dict{Any,Int64}\nparents::Dict{Int64,Array{Tuple{Any,Int64},1}}\ndirty::Array{Int64,1}\nroot::Int64\nanalyses::Array{Main.Metatheory.EGraphs.AbstractAnalysis,1}\n\n\n\n\n\n","category":"type"},{"location":"api/#Main.Metatheory.EGraphs.ExtractionAnalysis","page":"API Documentation","title":"Main.Metatheory.EGraphs.ExtractionAnalysis","text":"struct ExtractionAnalysis <: Main.Metatheory.EGraphs.AbstractAnalysis\n\nAn AbstractAnalysis that computes the cost of expression nodes and chooses the node with the smallest cost for each E-Class.\n\n\n\nFields\n\negraph::Main.Metatheory.EGraphs.EGraph\ncostfun::Function\ndata::Dict{Int64,Tuple{Any,Number}}\n\n\n\n\n\n","category":"type"},{"location":"api/#Main.Metatheory.EGraphs.RhsFunCache","page":"API Documentation","title":"Main.Metatheory.EGraphs.RhsFunCache","text":"Type representing a cache of RuntimeGeneratedFunctions corresponding to right hand sides of dynamic rules\n\n\n\n\n\n","category":"type"},{"location":"api/#Main.Metatheory.EGraphs.astsize-Tuple{Any}","page":"API Documentation","title":"Main.Metatheory.EGraphs.astsize","text":"A basic cost function, where the computed cost is the size (number of children) of the current expression.\n\n\n\nSignatures\n\nastsize(n::Any) -> Int64\n\n\n\n\nMethods\n\nastsize(n)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/extraction.jl:5.\n\nastsize(n)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/extraction.jl:6.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.EGraphs.astsize_inv-Tuple{Any}","page":"API Documentation","title":"Main.Metatheory.EGraphs.astsize_inv","text":"A basic cost function, where the computed cost is the size (number of children) of the current expression, times -1. Strives to get the largest expression\n\n\n\nSignatures\n\nastsize_inv(n::Any) -> Int64\n\n\n\n\nMethods\n\nastsize_inv(n)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/extraction.jl:13.\n\nastsize_inv(n)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/extraction.jl:14.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.EGraphs.ematchlist-Tuple{Main.Metatheory.EGraphs.EGraph,Array{Any,1},Array{Int64,1},Base.ImmutableDict{Any,Tuple{Main.Metatheory.EGraphs.EClass,Any}}}","page":"API Documentation","title":"Main.Metatheory.EGraphs.ematchlist","text":"From https://www.hpl.hp.com/techreports/2003/HPL-2003-148.pdf The iterator ematchlist matches a list of terms t to a list of E-nodes by first finding all substitutions that match the first term to the first E-node, and then extending each such substitution in all possible ways that match the remaining terms to the remaining E-nodes. The base case of this recursion is the empty list, which requires no extension to the substitution; the other case relies on Match to find the substitutions that match the first term to the first E-node.\n\n\n\nSignatures\n\nematchlist(e::Main.Metatheory.EGraphs.EGraph, t::Array{Any,1}, v::Array{Int64,1}, sub::Base.ImmutableDict{Any,Tuple{Main.Metatheory.EGraphs.EClass,Any}}) -> Array{Base.ImmutableDict{Any,Tuple{Main.Metatheory.EGraphs.EClass,Any}},1}\n\n\n\n\nMethods\n\nematchlist(e, t, v, sub)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/ematch.jl:25.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.EGraphs.eval_types_in_assertions-Tuple{Any,Module}","page":"API Documentation","title":"Main.Metatheory.EGraphs.eval_types_in_assertions","text":"When creating a theory, type assertions in the left hand contain symbols. We want to replace the type symbols with the real type values, to fully support the subtyping mechanism during pattern matching.\n\n\n\nSignatures\n\neval_types_in_assertions(x::Any, mod::Module) -> Any\n\n\n\n\nMethods\n\neval_types_in_assertions(x, mod)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/theory_compiler.jl:31.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.EGraphs.extract!-Tuple{Main.Metatheory.EGraphs.EGraph,Main.Metatheory.EGraphs.ExtractionAnalysis}","page":"API Documentation","title":"Main.Metatheory.EGraphs.extract!","text":"Given an ExtractionAnalysis, extract the expression with the smallest computed cost from an EGraph\n\n\n\nSignatures\n\nextract!(G::Main.Metatheory.EGraphs.EGraph, extran::Main.Metatheory.EGraphs.ExtractionAnalysis) -> Any\n\n\n\n\nMethods\n\nextract!(G, extran)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/extraction.jl:75.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.EGraphs.genrhsfun-Tuple{Main.Metatheory.Rule,Module}","page":"API Documentation","title":"Main.Metatheory.EGraphs.genrhsfun","text":"Generates a tuple containing the list of formal parameters (Symbols) and the RuntimeGeneratedFunction corresponding to the right hand side of a :dynamic Rule.\n\n\n\nSignatures\n\ngenrhsfun(rule::Main.Metatheory.Rule, mod::Module) -> Tuple{Array{Symbol,1},RuntimeGeneratedFunctions.RuntimeGeneratedFunction{_A,_B,_C,_D} where _D where _C where _B where _A}\n\n\n\n\nMethods\n\ngenrhsfun(rule, mod)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/theory_compiler.jl:11.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.EGraphs.isenode-Tuple{Expr}","page":"API Documentation","title":"Main.Metatheory.EGraphs.isenode","text":"Check if an expr is an enode âŸº all args are e-classes\n\n\n\nSignatures\n\nisenode(e::Expr) -> Bool\n\n\n\n\nMethods\n\nisenode(e)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/enode.jl:11.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.EGraphs.Schedulers","page":"API Documentation","title":"Metatheory.EGraphs.Schedulers","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"CurrentModule = Metatheory\nDocTestSetup  = quote\n    using Metatheory\nend","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Modules = [Metatheory.EGraphs.Schedulers]","category":"page"},{"location":"api/#Main.Metatheory.EGraphs.Schedulers.AbstractScheduler","page":"API Documentation","title":"Main.Metatheory.EGraphs.Schedulers.AbstractScheduler","text":"abstract type AbstractScheduler\n\nRepresents a rule scheduler for the equality saturation process\n\n\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"api/#Main.Metatheory.EGraphs.Schedulers.BackoffScheduler","page":"API Documentation","title":"Main.Metatheory.EGraphs.Schedulers.BackoffScheduler","text":"struct BackoffScheduler <: Main.Metatheory.EGraphs.Schedulers.AbstractScheduler\n\nA Rewrite Scheduler that implements exponential rule backoff. For each rewrite, there exists a configurable initial match limit. If a rewrite search yield more than this limit, then we ban this rule for number of iterations, double its limit, and double the time it will be banned next time.\n\nThis seems effective at preventing explosive rules like associativity from taking an unfair amount of resources.\n\n\n\nFields\n\ndata::Dict{Main.Metatheory.Rule,Main.Metatheory.EGraphs.Schedulers.BackoffSchedulerEntry}\nG::Main.Metatheory.EGraphs.EGraph\ntheory::Array{Main.Metatheory.Rule,1}\n\n\n\n\n\n","category":"type"},{"location":"api/#Main.Metatheory.EGraphs.Schedulers.SimpleScheduler","page":"API Documentation","title":"Main.Metatheory.EGraphs.Schedulers.SimpleScheduler","text":"struct SimpleScheduler <: Main.Metatheory.EGraphs.Schedulers.AbstractScheduler\n\nA simple Rewrite Scheduler that applies every rule every time\n\n\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"api/#Main.Metatheory.EGraphs.Schedulers.cansaturate-Tuple{Main.Metatheory.EGraphs.Schedulers.AbstractScheduler}","page":"API Documentation","title":"Main.Metatheory.EGraphs.Schedulers.cansaturate","text":"Should return true if the e-graph can be said to be saturated\n\n\n\nSignatures\n\ncansaturate(s::Main.Metatheory.EGraphs.Schedulers.AbstractScheduler) -> Bool\n\n\n\n\nMethods\n\ncansaturate(s)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/abstractscheduler.jl:12.\n\ncansaturate(s)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/backoffscheduler.jl:43.\n\ncansaturate(s)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/simplescheduler.jl:6.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.EGraphs.Schedulers.readstep!-Tuple{Main.Metatheory.EGraphs.Schedulers.AbstractScheduler}","page":"API Documentation","title":"Main.Metatheory.EGraphs.Schedulers.readstep!","text":"This function is called before pattern matching on the e-graph\n\n\n\nSignatures\n\nreadstep!(s::Main.Metatheory.EGraphs.Schedulers.AbstractScheduler)\n\n\n\n\nMethods\n\nreadstep!(s)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/abstractscheduler.jl:22.\n\nreadstep!(s)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/backoffscheduler.jl:45.\n\nreadstep!(s)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/simplescheduler.jl:13.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.EGraphs.Schedulers.shouldskip-Tuple{Main.Metatheory.EGraphs.Schedulers.AbstractScheduler,Main.Metatheory.Rule}","page":"API Documentation","title":"Main.Metatheory.EGraphs.Schedulers.shouldskip","text":"Should return true if the rule r should be skipped\n\n\n\nSignatures\n\nshouldskip(s::Main.Metatheory.EGraphs.Schedulers.AbstractScheduler, r::Main.Metatheory.Rule) -> Bool\n\n\n\n\nMethods\n\nshouldskip(s, r)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/abstractscheduler.jl:17.\n\nshouldskip(s, r)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/backoffscheduler.jl:27.\n\nshouldskip(s, r)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/simplescheduler.jl:7.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.EGraphs.Schedulers.writestep!-Tuple{Main.Metatheory.EGraphs.Schedulers.AbstractScheduler,Main.Metatheory.Rule}","page":"API Documentation","title":"Main.Metatheory.EGraphs.Schedulers.writestep!","text":"This function is called after pattern matching on the e-graph\n\n\n\nSignatures\n\nwritestep!(s::Main.Metatheory.EGraphs.Schedulers.AbstractScheduler, r::Main.Metatheory.Rule)\n\n\n\n\nMethods\n\nwritestep!(s, r)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/abstractscheduler.jl:27.\n\nwritestep!(s, rule)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/backoffscheduler.jl:61.\n\nwritestep!(s, r)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/simplescheduler.jl:14.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.Util","page":"API Documentation","title":"Metatheory.Util","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"CurrentModule = Metatheory\nDocTestSetup  = quote\n    using Metatheory\nend","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Modules = [Util]","category":"page"},{"location":"api/#Main.Metatheory.Util","page":"API Documentation","title":"Main.Metatheory.Util","text":"Definitions of various utility functions for metaprogramming\n\n\n\nImports\n\nBase\nBase.Meta\nCore\nDocStringExtensions\n\n\n\n\n\n","category":"module"},{"location":"api/#Main.Metatheory.Util.amp-Tuple{Any}","page":"API Documentation","title":"Main.Metatheory.Util.amp","text":"Add a & expression\n\n\n\nSignatures\n\namp(v::Any) -> Expr\n\n\n\n\nMethods\n\namp(v)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/Util.jl:15.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.Util.bf_walk!-Tuple{Any,Any,Vararg{Any,N} where N}","page":"API Documentation","title":"Main.Metatheory.Util.bf_walk!","text":"Breadth First Walk (Tree Prewalk) on expressions mutates expression in-place.\n\n\n\nSignatures\n\nbf_walk!(f::Any, e::Any, f_args::Vararg{Any,N} where N; skip, skip_call) -> Any\n\n\n\n\nMethods\n\nbf_walk!(f, e, f_args; skip, skip_call)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/walks.jl:45.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.Util.bf_walk-Tuple{Any,Any,Vararg{Any,N} where N}","page":"API Documentation","title":"Main.Metatheory.Util.bf_walk","text":"Breadth First Walk (Tree Prewalk) on expressions. Does not mutate expressions.\n\n\n\nSignatures\n\nbf_walk(f::Any, e::Any, f_args::Vararg{Any,N} where N; skip, skip_call) -> Any\n\n\n\n\nMethods\n\nbf_walk(f, e, f_args; skip, skip_call)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/walks.jl:65.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.Util.binarize!-Tuple{Any,Symbol}","page":"API Documentation","title":"Main.Metatheory.Util.binarize!","text":"HARD FIX of n-arity of operators in Expr trees\n\n\n\nSignatures\n\nbinarize!(e::Any, op::Symbol) -> Any\n\n\n\n\nMethods\n\nbinarize!(e, op)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/cleaning.jl:11.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.Util.block-Tuple","page":"API Documentation","title":"Main.Metatheory.Util.block","text":"Make a block expression from an array of exprs\n\n\n\nSignatures\n\nblock(vs::Vararg{Any,N} where N) -> Any\n\n\n\n\nMethods\n\nblock(vs)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/Util.jl:13.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.Util.cleanast-Tuple{Any}","page":"API Documentation","title":"Main.Metatheory.Util.cleanast","text":"Binarize n-ary operators (+ and *) and call rmlines\n\n\n\nSignatures\n\ncleanast(ex::Any) -> Any\n\n\n\n\nMethods\n\ncleanast(ex)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/cleaning.jl:22.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.Util.df_walk!-Tuple{Any,Any,Vararg{Any,N} where N}","page":"API Documentation","title":"Main.Metatheory.Util.df_walk!","text":"Depth First Walk (Tree Postwalk) on expressions, mutates expression in-place.\n\n\n\nSignatures\n\ndf_walk!(f::Any, e::Any, f_args::Vararg{Any,N} where N; skip, skip_call) -> Any\n\n\n\n\nMethods\n\ndf_walk!(f, e, f_args; skip, skip_call)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/walks.jl:4.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.Util.df_walk-Tuple{Any,Any,Vararg{Any,N} where N}","page":"API Documentation","title":"Main.Metatheory.Util.df_walk","text":"Depth First Walk (Tree Postwalk) on expressions. Does not mutate expressions.\n\n\n\nSignatures\n\ndf_walk(f::Any, e::Any, f_args::Vararg{Any,N} where N; skip, skip_call) -> Any\n\n\n\n\nMethods\n\ndf_walk(f, e, f_args; skip, skip_call)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/walks.jl:22.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.Util.dollar-Tuple{Any}","page":"API Documentation","title":"Main.Metatheory.Util.dollar","text":"Add a dollar expression\n\n\n\nSignatures\n\ndollar(v::Any) -> Expr\n\n\n\n\nMethods\n\ndollar(v)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/Util.jl:11.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.Util.normalize-Tuple{Any,Any,Vararg{Any,N} where N}","page":"API Documentation","title":"Main.Metatheory.Util.normalize","text":"Iterates a function f on datum until a fixed point is reached where f(x) == x\n\n\n\nSignatures\n\nnormalize(f::Any, datum::Any, fargs::Vararg{Any,N} where N; callback) -> Any\n\n\n\n\nMethods\n\nnormalize(f, datum, fargs; callback)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/fixpoint.jl:4.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.Util.normalize_nocycle-Tuple{Any,Any,Vararg{Any,N} where N}","page":"API Documentation","title":"Main.Metatheory.Util.normalize_nocycle","text":"Like normalize but keeps a vector of hashes to detect cycles, returns the current datum when a cycle is detected\n\n\n\nSignatures\n\nnormalize_nocycle(f::Any, datum::Any, fargs::Vararg{Any,N} where N; callback) -> Any\n\n\n\n\nMethods\n\nnormalize_nocycle(f, datum, fargs; callback)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/fixpoint.jl:20.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.Util.rmlines-Tuple{Expr}","page":"API Documentation","title":"Main.Metatheory.Util.rmlines","text":"Remove LineNumberNode from quoted blocks of code\n\n\n\nSignatures\n\nrmlines(e::Expr) -> Any\n\n\n\n\nMethods\n\nrmlines(e)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/cleaning.jl:4.\n\n\n\n\n\n","category":"method"},{"location":"#Metatheory.jl","page":"Metatheory.jl","title":"Metatheory.jl","text":"","category":"section"},{"location":"","page":"Metatheory.jl","title":"Metatheory.jl","text":"<p align=\"center\">\n<img width=\"400px\" src=\"https://raw.githubusercontent.com/0x0f0f0f/Metatheory.jl/master/docs/src/assets/dragon.jpg\"/>\n</p>","category":"page"},{"location":"","page":"Metatheory.jl","title":"Metatheory.jl","text":"Metatheory.jl is a general purpose metaprogramming and algebraic computation library for the Julia programming language, designed to take advantage of the powerful reflection capabilities to bridge the gap between symbolic mathematics, abstract interpretation, equational reasoning, optimization, composable compiler transforms, and advanced homoiconic pattern matching features.","category":"page"},{"location":"","page":"Metatheory.jl","title":"Metatheory.jl","text":"Read the preprint on arXiv.","category":"page"}]
}
