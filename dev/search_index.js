var documenterSearchIndex = {"docs":
[{"location":"modules/egraphs/#Metatheory.EGraphs","page":"Metatheory.EGraphs","title":"Metatheory.EGraphs","text":"","category":"section"},{"location":"modules/egraphs/","page":"Metatheory.EGraphs","title":"Metatheory.EGraphs","text":"CurrentModule = Metatheory\nDocTestSetup  = quote\n    using Metatheory\nend","category":"page"},{"location":"modules/egraphs/","page":"Metatheory.EGraphs","title":"Metatheory.EGraphs","text":"Modules = [EGraphs]","category":"page"},{"location":"modules/egraphs/#Metatheory.EGraphs.RhsFunCache","page":"Metatheory.EGraphs","title":"Metatheory.EGraphs.RhsFunCache","text":"Type representing a cache of RuntimeGeneratedFunctions corresponding to right hand sides of dynamic rules\n\n\n\n\n\n","category":"type"},{"location":"modules/egraphs/#Metatheory.EGraphs.eval_types_in_assertions-Tuple{Any,Module}","page":"Metatheory.EGraphs","title":"Metatheory.EGraphs.eval_types_in_assertions","text":"When creating a theory, type assertions in the left hand contain symbols. We want to replace the type symbols with the real type values, to fully support the subtyping mechanism during pattern matching.\n\n\n\n\n\n","category":"method"},{"location":"modules/egraphs/#Metatheory.EGraphs.genrhsfun-Tuple{Rule,Module}","page":"Metatheory.EGraphs","title":"Metatheory.EGraphs.genrhsfun","text":"Generates a tuple containing the list of formal parameters (Symbols) and the RuntimeGeneratedFunction corresponding to the right hand side of a :dynamic Rule.\n\n\n\n\n\n","category":"method"},{"location":"modules/metatheory/#Metatheory","page":"Metatheory","title":"Metatheory","text":"","category":"section"},{"location":"modules/metatheory/","page":"Metatheory","title":"Metatheory","text":"Modules = [Metatheory]","category":"page"},{"location":"modules/metatheory/#Metatheory.compile_theory-Tuple{Array{Rule,1},Module}","page":"Metatheory","title":"Metatheory.compile_theory","text":"Compile a theory to a closure that does the pattern matching job Returns a RuntimeGeneratedFunction, which does not use eval and is as fast as a regular Julia anonymous function ðŸ”¥\n\n\n\n\n\n","category":"method"},{"location":"modules/metatheory/#Metatheory.@compile_theory-Tuple{Any}","page":"Metatheory","title":"Metatheory.@compile_theory","text":"Compile a theory at runtime to a closure that does the pattern matching job\n\n\n\n\n\n","category":"macro"},{"location":"modules/util/#Metatheory.Util","page":"Metatheory.Util","title":"Metatheory.Util","text":"","category":"section"},{"location":"modules/util/","page":"Metatheory.Util","title":"Metatheory.Util","text":"CurrentModule = Metatheory\nDocTestSetup  = quote\n    using Metatheory\nend","category":"page"},{"location":"modules/util/","page":"Metatheory.Util","title":"Metatheory.Util","text":"Modules = [Util]","category":"page"},{"location":"modules/util/#Metatheory.Util","page":"Metatheory.Util","title":"Metatheory.Util","text":"Definitions of various utility functions for metaprogramming\n\n\n\n\n\n","category":"module"},{"location":"modules/util/#Metatheory.Util.amp-Tuple{Any}","page":"Metatheory.Util","title":"Metatheory.Util.amp","text":"Add a & expression\n\n\n\n\n\n","category":"method"},{"location":"modules/util/#Metatheory.Util.bf_walk!-Tuple{Any,Any,Vararg{Any,N} where N}","page":"Metatheory.Util","title":"Metatheory.Util.bf_walk!","text":"Breadth First Walk (Tree Prewalk) on expressions mutates expression in-place.\n\n\n\n\n\n","category":"method"},{"location":"modules/util/#Metatheory.Util.bf_walk-Tuple{Any,Any,Vararg{Any,N} where N}","page":"Metatheory.Util","title":"Metatheory.Util.bf_walk","text":"Breadth First Walk (Tree Prewalk) on expressions. Does not mutate expressions.\n\n\n\n\n\n","category":"method"},{"location":"modules/util/#Metatheory.Util.binarize!-Tuple{Any,Symbol}","page":"Metatheory.Util","title":"Metatheory.Util.binarize!","text":"HARD FIX of n-arity of operators in Expr trees\n\n\n\n\n\n","category":"method"},{"location":"modules/util/#Metatheory.Util.block-Tuple","page":"Metatheory.Util","title":"Metatheory.Util.block","text":"Make a block expression from an array of exprs\n\n\n\n\n\n","category":"method"},{"location":"modules/util/#Metatheory.Util.cleanast-Tuple{Any}","page":"Metatheory.Util","title":"Metatheory.Util.cleanast","text":"Binarize n-ary operators (+ and *) and call rmlines\n\n\n\n\n\n","category":"method"},{"location":"modules/util/#Metatheory.Util.df_walk!-Tuple{Any,Any,Vararg{Any,N} where N}","page":"Metatheory.Util","title":"Metatheory.Util.df_walk!","text":"Depth First Walk (Tree Postwalk) on expressions, mutates expression in-place.\n\n\n\n\n\n","category":"method"},{"location":"modules/util/#Metatheory.Util.df_walk-Tuple{Any,Any,Vararg{Any,N} where N}","page":"Metatheory.Util","title":"Metatheory.Util.df_walk","text":"Depth First Walk (Tree Postwalk) on expressions. Does not mutate expressions.\n\n\n\n\n\n","category":"method"},{"location":"modules/util/#Metatheory.Util.dollar-Tuple{Any}","page":"Metatheory.Util","title":"Metatheory.Util.dollar","text":"Add a dollar expression\n\n\n\n\n\n","category":"method"},{"location":"modules/util/#Metatheory.Util.normalize-Tuple{Any,Any,Vararg{Any,N} where N}","page":"Metatheory.Util","title":"Metatheory.Util.normalize","text":"Iterates a function f on datum until a fixed point is reached where f(x) == x\n\n\n\n\n\n","category":"method"},{"location":"modules/util/#Metatheory.Util.normalize_nocycle-Tuple{Any,Any,Vararg{Any,N} where N}","page":"Metatheory.Util","title":"Metatheory.Util.normalize_nocycle","text":"Like normalize but keeps a vector of hashes to detect cycles, returns the current datum when a cycle is detected\n\n\n\n\n\n","category":"method"},{"location":"modules/util/#Metatheory.Util.rmlines-Tuple{Expr}","page":"Metatheory.Util","title":"Metatheory.Util.rmlines","text":"Remove LineNumberNode from quoted blocks of code\n\n\n\n\n\n","category":"method"},{"location":"#Metatheory.jl","page":"Metatheory.jl","title":"Metatheory.jl","text":"","category":"section"},{"location":"","page":"Metatheory.jl","title":"Metatheory.jl","text":"Docs will appear here some time in the near future.","category":"page"}]
}
