var documenterSearchIndex = {"docs":
[{"location":"#Example","page":"Example","title":"Example","text":"","category":"section"},{"location":"","page":"Example","title":"Example","text":"Example Julia package repo.","category":"page"},{"location":"","page":"Example","title":"Example","text":"Modules = [Metatheory]","category":"page"},{"location":"#Metatheory.BackoffScheduler","page":"Example","title":"Metatheory.BackoffScheduler","text":"A Rewrite Scheduler that implements exponential rule backoff. For each rewrite, there exists a configurable initial match limit. If a rewrite search yield more than this limit, then we ban this rule for number of iterations, double its limit, and double the time it will be banned next time.\n\nThis seems effective at preventing explosive rules like associativity from taking an unfair amount of resources.\n\n\n\n\n\n","category":"type"},{"location":"#Metatheory.RhsFunCache","page":"Example","title":"Metatheory.RhsFunCache","text":"Type representing a cache of RuntimeGeneratedFunctions corresponding to right hand sides of dynamic rules\n\n\n\n\n\n","category":"type"},{"location":"#Metatheory.amp-Tuple{Any}","page":"Example","title":"Metatheory.amp","text":"Add a & expression\n\n\n\n\n\n","category":"method"},{"location":"#Metatheory.block-Tuple","page":"Example","title":"Metatheory.block","text":"Make a block expression from an array of exprs\n\n\n\n\n\n","category":"method"},{"location":"#Metatheory.cleanast-Tuple{Any}","page":"Example","title":"Metatheory.cleanast","text":"Binarize n-ary operators (+ and *) and call rmlines\n\n\n\n\n\n","category":"method"},{"location":"#Metatheory.dollar-Tuple{Any}","page":"Example","title":"Metatheory.dollar","text":"Add a dollar expression\n\n\n\n\n\n","category":"method"},{"location":"#Metatheory.eval_types_in_assertions-Tuple{Any}","page":"Example","title":"Metatheory.eval_types_in_assertions","text":"When creating a theory, type assertions in the left hand contain symbols. We want to replace the type symbols with the real type values, to fully support the subtyping mechanism during pattern matching.\n\n\n\n\n\n","category":"method"},{"location":"#Metatheory.genrhsfun-Tuple{Rule,Module}","page":"Example","title":"Metatheory.genrhsfun","text":"Generates a tuple containing the list of formal parameters (Symbols) and the RuntimeGeneratedFunction corresponding to the right hand side of a :dynamic Rule.\n\n\n\n\n\n","category":"method"},{"location":"#Metatheory.rmlines-Tuple{Expr}","page":"Example","title":"Metatheory.rmlines","text":"Remove LineNumberNode from quoted blocks of code\n\n\n\n\n\n","category":"method"}]
}
