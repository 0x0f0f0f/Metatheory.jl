var documenterSearchIndex = {"docs":
[{"location":"api/#API-Documentation","page":"API Documentation","title":"API Documentation","text":"","category":"section"},{"location":"api/#Metatheory","page":"API Documentation","title":"Metatheory","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Modules = [Metatheory]","category":"page"},{"location":"api/#Main.Metatheory.Theory","page":"API Documentation","title":"Main.Metatheory.Theory","text":"A Theory is either a vector of Rule or a compiled, callable function.\n\n\n\n\n\n","category":"type"},{"location":"api/#Main.Metatheory.Rule-Tuple{Expr}","page":"API Documentation","title":"Main.Metatheory.Rule","text":"Construct a Rule from a quoted expression. You can also use the [@rule] macro to create a Rule.\n\nSymbolic Rules\n\nRules defined as left_hand => right_hand are called symbolic rules. Application of a symbolic Rule is a replacement of the left_hand pattern with the right_hand substitution, with the correct instantiation of pattern variables. Function call symbols are not treated as pattern variables, all other identifiers are treated as pattern variables. Literals such as 5, :e, \"hello\" are not treated as pattern variables.\n\nDynamic Rules\n\nRules defined as left_hand |> right_hand are called dynamic rules. Dynamic rules behave like anonymous functions. Instead of a symbolic substitution, the right hand of a dynamic |> rule is evaluated during rewriting: matched values are bound to pattern variables as in a regular function call. This allows for dynamic computation of\n\nType Assertions\n\nType assertions are supported in the left hand of rules to match and access literal values both when using classic rewriting and EGraph based rewriting. To use a type assertion pattern, add ::T after a pattern variable in the left_hand of a rule.\n\n\n\nExamples\n\nSymbolic rule\n\nRule(:(a * b => b * a))\n\nRule(:(a::Number * b::Number |> a*b))\n\n\n\nSignatures\n\nRule(e::Expr; mod) -> Main.Metatheory.Rule\n\n\n\n\nMethods\n\nRule(e; mod)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/rule.jl:64.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.compile_theory-Tuple{Array{Main.Metatheory.Rule,1},Module}","page":"API Documentation","title":"Main.Metatheory.compile_theory","text":"Compile a theory to a closure that does the pattern matching job Returns a RuntimeGeneratedFunction, which does not use eval and is as fast as a regular Julia anonymous function ðŸ”¥\n\n\n\nSignatures\n\ncompile_theory(theory::Array{Main.Metatheory.Rule,1}, mod::Module; __source__) -> RuntimeGeneratedFunctions.RuntimeGeneratedFunction{_A,_B,_C,_D} where _D where _C where _B where _A\n\n\n\n\nMethods\n\ncompile_theory(theory, mod; __source__)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/matchcore_compiler.jl:62.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.eval_types_in_assertions-Tuple{Any,Module}","page":"API Documentation","title":"Main.Metatheory.eval_types_in_assertions","text":"When creating a theory, type assertions in the left hand contain symbols. We want to replace the type symbols with the real type values, to fully support the subtyping mechanism during pattern matching.\n\n\n\nSignatures\n\neval_types_in_assertions(x::Any, mod::Module) -> Any\n\n\n\n\nMethods\n\neval_types_in_assertions(x, mod)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/rule.jl:126.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.genrhsfun-Tuple{Any,Any,Module}","page":"API Documentation","title":"Main.Metatheory.genrhsfun","text":"Generates a tuple containing the list of formal parameters (Symbols) and the RuntimeGeneratedFunction corresponding to the right hand side of a :dynamic Rule.\n\n\n\nSignatures\n\ngenrhsfun(left::Any, right::Any, mod::Module) -> Tuple{Array{Symbol,1},RuntimeGeneratedFunctions.RuntimeGeneratedFunction{_A,_B,_C,_D} where _D where _C where _B where _A}\n\n\n\n\nMethods\n\ngenrhsfun(left, right, mod)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/rule.jl:106.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.rewrite-Tuple{Any,Union{Array{Main.Metatheory.Rule,1}, Function}}","page":"API Documentation","title":"Main.Metatheory.rewrite","text":"This function executes a classical rewriting algorithm on a Julia expression ex. Classical rewriting applies rule in order with a fixed point iteration:\n\nThis algorithm heavily relies on RuntimeGeneratedFunctions.jl and the MatchCore pattern matcher. NOTE: this does not involve the use of EGraphs.EGraph or equality saturation (EGraphs.saturate!). When using rewrite, be aware of infinite loops: Since rules are matched in order in every iteration, it is possible that commonly used symbolic rules such as commutativity or associativity of operators may cause this algorithm to have a cycling computation instantly. This algorithm detects cycling computation by keeping an history of hashes, and instantly returns when a cycle is detected.\n\nThis algorithm is suitable for simple, deterministic symbolic rewrites. For more advanced use cases, where it is needed to apply multiple rewrites at the same time, or it is known that rules are causing loops, please use EGraphs.EGraph and equality saturation (EGraphs.saturate!).\n\n\n\nSignatures\n\nrewrite(ex::Any, theory::Union{Array{Main.Metatheory.Rule,1}, Function}; __source__, order, m, timeout) -> Any\n\n\n\n\nMethods\n\nrewrite(ex, theory; __source__, order, m, timeout)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/rewrite.jl:28.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.@compile_theory-Tuple{Any}","page":"API Documentation","title":"Main.Metatheory.@compile_theory","text":"Compile a theory at runtime to a closure that does the pattern matching job\n\n\n\nSignatures\n\n\n\nMethods\n\n\n\n\n\n","category":"macro"},{"location":"api/#Metatheory.EGraphs","page":"API Documentation","title":"Metatheory.EGraphs","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"CurrentModule = Metatheory\nDocTestSetup  = quote\n    using Metatheory\nend","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Modules = [Metatheory.EGraphs]","category":"page"},{"location":"api/#Main.Metatheory.EGraphs.AbstractAnalysis","page":"API Documentation","title":"Main.Metatheory.EGraphs.AbstractAnalysis","text":"abstract type AbstractAnalysis\n\nAbstract type representing an EGraph analysis, attaching values from a join semi-lattice domain to an EGraph\n\n\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"api/#Main.Metatheory.EGraphs.EGraph","page":"API Documentation","title":"Main.Metatheory.EGraphs.EGraph","text":"mutable struct EGraph\n\nA concrete type representing an [EGraph]. See the egg paper for implementation details\n\n\n\nFields\n\nU::DataStructures.IntDisjointSets\nstores the equality relations over e-class ids\nM::Dict{Int64,Array{Any,1}}\nmap from eclass id to eclasses\nH::Dict{Any,Int64}\nparents::Dict{Int64,Array{Tuple{Any,Int64},1}}\ndirty::Array{Int64,1}\nworklist for ammortized upwards merging\nroot::Int64\nanalyses::Array{Main.Metatheory.EGraphs.AbstractAnalysis,1}\nA vector of analyses associated to the EGraph\nlazy_analyses::Array{Main.Metatheory.EGraphs.AbstractAnalysis,1}\nSame as above, but the analyses values are computed lazily\n\n\n\n\n\n","category":"type"},{"location":"api/#Main.Metatheory.EGraphs.ExtractionAnalysis","page":"API Documentation","title":"Main.Metatheory.EGraphs.ExtractionAnalysis","text":"struct ExtractionAnalysis <: Main.Metatheory.EGraphs.AbstractAnalysis\n\nAn AbstractAnalysis that computes the cost of expression nodes and chooses the node with the smallest cost for each E-Class.\n\n\n\nFields\n\negraph::Main.Metatheory.EGraphs.EGraph\ncostfun::Function\ndata::Dict{Int64,Tuple{Any,Number}}\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.merge!-Tuple{Main.Metatheory.EGraphs.EGraph,Int64,Int64}","page":"API Documentation","title":"Base.merge!","text":"Given an EGraph and two e-class ids, set the two e-classes as equal.\n\n\n\nSignatures\n\nmerge!(G::Main.Metatheory.EGraphs.EGraph, a::Int64, b::Int64) -> Int64\n\n\n\n\nMethods\n\nmerge!(G, a, b)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egg.jl:121.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.EGraphs.add!-Tuple{Main.Metatheory.EGraphs.EGraph,Any}","page":"API Documentation","title":"Main.Metatheory.EGraphs.add!","text":"Inserts an e-node in an EGraph\n\n\n\nSignatures\n\nadd!(G::Main.Metatheory.EGraphs.EGraph, n::Any) -> Main.Metatheory.EGraphs.EClass\n\n\n\n\nMethods\n\nadd!(G, n)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egg.jl:71.\n\nadd!(g, c)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egg.jl:94.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.EGraphs.addanalysis!-Tuple{Main.Metatheory.EGraphs.EGraph,Type{var\"#s6\"} where var\"#s6\"<:Main.Metatheory.EGraphs.AbstractAnalysis,Vararg{Any,N} where N}","page":"API Documentation","title":"Main.Metatheory.EGraphs.addanalysis!","text":"Adds an AbstractAnalysis to an EGraph. An EGraph can only contain one analysis of type AnType. The Analysis is computed for the whole EGraph. This may be very slow for large EGraphs\n\n\n\nSignatures\n\naddanalysis!(g::Main.Metatheory.EGraphs.EGraph, AnType::Type{var\"#s6\"} where var\"#s6\"<:Main.Metatheory.EGraphs.AbstractAnalysis, args::Vararg{Any,N} where N; lazy) -> Any\n\n\n\n\nMethods\n\naddanalysis!(g, AnType, args; lazy)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/analysis.jl:8.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.EGraphs.addexpr!-Tuple{Main.Metatheory.EGraphs.EGraph,Any}","page":"API Documentation","title":"Main.Metatheory.EGraphs.addexpr!","text":"Recursively traverse an Expr and insert terms into an EGraph. If e is not an Expr, then directly insert the literal into the EGraph.\n\n\n\nSignatures\n\naddexpr!(G::Main.Metatheory.EGraphs.EGraph, e::Any) -> Main.Metatheory.EGraphs.EClass\n\n\n\n\nMethods\n\naddexpr!(G, e)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egg.jl:101.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.EGraphs.analyze!-Tuple{Main.Metatheory.EGraphs.EGraph,Main.Metatheory.EGraphs.AbstractAnalysis,Array{Int64,1}}","page":"API Documentation","title":"Main.Metatheory.EGraphs.analyze!","text":"WARNING. This function is unstable.\n\n\n\nSignatures\n\nanalyze!(g::Main.Metatheory.EGraphs.EGraph, analysis::Main.Metatheory.EGraphs.AbstractAnalysis, ids::Array{Int64,1}) -> Main.Metatheory.EGraphs.AbstractAnalysis\n\n\n\n\nMethods\n\nanalyze!(g, analysis, ids)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/analysis.jl:38.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.EGraphs.astsize-Tuple{Any}","page":"API Documentation","title":"Main.Metatheory.EGraphs.astsize","text":"A basic cost function, where the computed cost is the size (number of children) of the current expression.\n\n\n\nSignatures\n\nastsize(n::Any) -> Int64\n\n\n\n\nMethods\n\nastsize(n)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/extraction.jl:5.\n\nastsize(n)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/extraction.jl:6.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.EGraphs.astsize_inv-Tuple{Any}","page":"API Documentation","title":"Main.Metatheory.EGraphs.astsize_inv","text":"A basic cost function, where the computed cost is the size (number of children) of the current expression, times -1. Strives to get the largest expression\n\n\n\nSignatures\n\nastsize_inv(n::Any) -> Int64\n\n\n\n\nMethods\n\nastsize_inv(n)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/extraction.jl:13.\n\nastsize_inv(n)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/extraction.jl:14.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.EGraphs.ematchlist-Tuple{Main.Metatheory.EGraphs.EGraph,Array{Any,1},Array{Int64,1},Base.ImmutableDict{Any,Tuple{Main.Metatheory.EGraphs.EClass,Any}}}","page":"API Documentation","title":"Main.Metatheory.EGraphs.ematchlist","text":"From https://www.hpl.hp.com/techreports/2003/HPL-2003-148.pdf The iterator ematchlist matches a list of terms t to a list of E-nodes by first finding all substitutions that match the first term to the first E-node, and then extending each such substitution in all possible ways that match the remaining terms to the remaining E-nodes. The base case of this recursion is the empty list, which requires no extension to the substitution; the other case relies on Match to find the substitutions that match the first term to the first E-node.\n\n\n\nSignatures\n\nematchlist(e::Main.Metatheory.EGraphs.EGraph, t::Array{Any,1}, v::Array{Int64,1}, sub::Base.ImmutableDict{Any,Tuple{Main.Metatheory.EGraphs.EClass,Any}}) -> Array{Base.ImmutableDict{Any,Tuple{Main.Metatheory.EGraphs.EClass,Any}},1}\n\n\n\n\nMethods\n\nematchlist(e, t, v, sub)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/ematch.jl:25.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.EGraphs.extract!-Tuple{Main.Metatheory.EGraphs.EGraph,Main.Metatheory.EGraphs.ExtractionAnalysis}","page":"API Documentation","title":"Main.Metatheory.EGraphs.extract!","text":"Given an ExtractionAnalysis, extract the expression with the smallest computed cost from an EGraph\n\n\n\nSignatures\n\nextract!(G::Main.Metatheory.EGraphs.EGraph, extran::Main.Metatheory.EGraphs.ExtractionAnalysis) -> Any\n\n\n\n\nMethods\n\nextract!(G, extran)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/extraction.jl:72.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.EGraphs.find-Tuple{Main.Metatheory.EGraphs.EGraph,Int64}","page":"API Documentation","title":"Main.Metatheory.EGraphs.find","text":"Returns the canonical e-class id for a given e-class.\n\n\n\nSignatures\n\nfind(G::Main.Metatheory.EGraphs.EGraph, a::Int64) -> Int64\n\n\n\n\nMethods\n\nfind(G, a)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egg.jl:169.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.EGraphs.isenode-Tuple{Expr}","page":"API Documentation","title":"Main.Metatheory.EGraphs.isenode","text":"Check if an expr is an enode âŸº all args are e-classes\n\n\n\nSignatures\n\nisenode(e::Expr) -> Bool\n\n\n\n\nMethods\n\nisenode(e)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/enode.jl:11.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.EGraphs.reachable-Tuple{Main.Metatheory.EGraphs.EGraph,Int64}","page":"API Documentation","title":"Main.Metatheory.EGraphs.reachable","text":"Recursive function that traverses an EGraph and returns a vector of all reachable e-classes from a given e-class id.\n\n\n\nSignatures\n\nreachable(g::Main.Metatheory.EGraphs.EGraph, id::Int64; hist) -> Array{Int64,1}\n\n\n\n\nMethods\n\nreachable(g, id; hist)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egg.jl:262.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.EGraphs.rebuild!-Tuple{Main.Metatheory.EGraphs.EGraph}","page":"API Documentation","title":"Main.Metatheory.EGraphs.rebuild!","text":"This function restores invariants and executes upwards merging in an EGraph. See the egg paper for more details.\n\n\n\nSignatures\n\nrebuild!(G::Main.Metatheory.EGraphs.EGraph) -> Union{Nothing, Int64}\n\n\n\n\nMethods\n\nrebuild!(G)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egg.jl:178.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.EGraphs.saturate!-Tuple{Main.Metatheory.EGraphs.EGraph,Array{Main.Metatheory.Rule,1}}","page":"API Documentation","title":"Main.Metatheory.EGraphs.saturate!","text":"Given an EGraph and a collection of rewrite rules, execute the equality saturation algorithm.\n\n\n\nSignatures\n\nsaturate!(egraph::Main.Metatheory.EGraphs.EGraph, theory::Array{Main.Metatheory.Rule,1}; mod, timeout, stopwhen, sizeout, scheduler) -> Tuple{Bool,Main.Metatheory.EGraphs.EGraph}\n\n\n\n\nMethods\n\nsaturate!(egraph, theory; mod, timeout, stopwhen, sizeout, scheduler)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/saturation.jl:82.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.EGraphs.Schedulers","page":"API Documentation","title":"Metatheory.EGraphs.Schedulers","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"CurrentModule = Metatheory\nDocTestSetup  = quote\n    using Metatheory\nend","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Modules = [Metatheory.EGraphs.Schedulers]","category":"page"},{"location":"api/#Main.Metatheory.EGraphs.Schedulers.AbstractScheduler","page":"API Documentation","title":"Main.Metatheory.EGraphs.Schedulers.AbstractScheduler","text":"abstract type AbstractScheduler\n\nRepresents a rule scheduler for the equality saturation process\n\n\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"api/#Main.Metatheory.EGraphs.Schedulers.BackoffScheduler","page":"API Documentation","title":"Main.Metatheory.EGraphs.Schedulers.BackoffScheduler","text":"struct BackoffScheduler <: Main.Metatheory.EGraphs.Schedulers.AbstractScheduler\n\nA Rewrite Scheduler that implements exponential rule backoff. For each rewrite, there exists a configurable initial match limit. If a rewrite search yield more than this limit, then we ban this rule for number of iterations, double its limit, and double the time it will be banned next time.\n\nThis seems effective at preventing explosive rules like associativity from taking an unfair amount of resources.\n\n\n\nFields\n\ndata::Dict{Main.Metatheory.Rule,Main.Metatheory.EGraphs.Schedulers.BackoffSchedulerEntry}\nG::Main.Metatheory.EGraphs.EGraph\ntheory::Array{Main.Metatheory.Rule,1}\n\n\n\n\n\n","category":"type"},{"location":"api/#Main.Metatheory.EGraphs.Schedulers.SimpleScheduler","page":"API Documentation","title":"Main.Metatheory.EGraphs.Schedulers.SimpleScheduler","text":"struct SimpleScheduler <: Main.Metatheory.EGraphs.Schedulers.AbstractScheduler\n\nA simple Rewrite Scheduler that applies every rule every time\n\n\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"api/#Main.Metatheory.EGraphs.Schedulers.cansaturate-Tuple{Main.Metatheory.EGraphs.Schedulers.AbstractScheduler}","page":"API Documentation","title":"Main.Metatheory.EGraphs.Schedulers.cansaturate","text":"Should return true if the e-graph can be said to be saturated\n\n\n\nSignatures\n\ncansaturate(s::Main.Metatheory.EGraphs.Schedulers.AbstractScheduler) -> Bool\n\n\n\n\nMethods\n\ncansaturate(s)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/abstractscheduler.jl:12.\n\ncansaturate(s)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/backoffscheduler.jl:43.\n\ncansaturate(s)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/simplescheduler.jl:6.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.EGraphs.Schedulers.readstep!-Tuple{Main.Metatheory.EGraphs.Schedulers.AbstractScheduler}","page":"API Documentation","title":"Main.Metatheory.EGraphs.Schedulers.readstep!","text":"This function is called before pattern matching on the e-graph\n\n\n\nSignatures\n\nreadstep!(s::Main.Metatheory.EGraphs.Schedulers.AbstractScheduler)\n\n\n\n\nMethods\n\nreadstep!(s)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/abstractscheduler.jl:22.\n\nreadstep!(s)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/backoffscheduler.jl:45.\n\nreadstep!(s)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/simplescheduler.jl:13.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.EGraphs.Schedulers.shouldskip-Tuple{Main.Metatheory.EGraphs.Schedulers.AbstractScheduler,Main.Metatheory.Rule}","page":"API Documentation","title":"Main.Metatheory.EGraphs.Schedulers.shouldskip","text":"Should return true if the rule r should be skipped\n\n\n\nSignatures\n\nshouldskip(s::Main.Metatheory.EGraphs.Schedulers.AbstractScheduler, r::Main.Metatheory.Rule) -> Bool\n\n\n\n\nMethods\n\nshouldskip(s, r)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/abstractscheduler.jl:17.\n\nshouldskip(s, r)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/backoffscheduler.jl:27.\n\nshouldskip(s, r)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/simplescheduler.jl:7.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.EGraphs.Schedulers.writestep!-Tuple{Main.Metatheory.EGraphs.Schedulers.AbstractScheduler,Main.Metatheory.Rule}","page":"API Documentation","title":"Main.Metatheory.EGraphs.Schedulers.writestep!","text":"This function is called after pattern matching on the e-graph\n\n\n\nSignatures\n\nwritestep!(s::Main.Metatheory.EGraphs.Schedulers.AbstractScheduler, r::Main.Metatheory.Rule)\n\n\n\n\nMethods\n\nwritestep!(s, r)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/abstractscheduler.jl:27.\n\nwritestep!(s, rule)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/backoffscheduler.jl:61.\n\nwritestep!(s, r)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/simplescheduler.jl:14.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.Util","page":"API Documentation","title":"Metatheory.Util","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"CurrentModule = Metatheory\nDocTestSetup  = quote\n    using Metatheory\nend","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Modules = [Util]","category":"page"},{"location":"api/#Main.Metatheory.Util","page":"API Documentation","title":"Main.Metatheory.Util","text":"Definitions of various utility functions for metaprogramming\n\n\n\nImports\n\nBase\nBase.Meta\nCore\nDocStringExtensions\n\n\n\n\n\n","category":"module"},{"location":"api/#Main.Metatheory.Util.amp-Tuple{Any}","page":"API Documentation","title":"Main.Metatheory.Util.amp","text":"Add a & expression\n\n\n\nSignatures\n\namp(v::Any) -> Expr\n\n\n\n\nMethods\n\namp(v)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/Util.jl:22.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.Util.bf_walk!-Tuple{Any,Any,Vararg{Any,N} where N}","page":"API Documentation","title":"Main.Metatheory.Util.bf_walk!","text":"Breadth First Walk (Tree Prewalk) on expressions mutates expression in-place.\n\n\n\nSignatures\n\nbf_walk!(f::Any, e::Any, f_args::Vararg{Any,N} where N; skip, skip_call) -> Any\n\n\n\n\nMethods\n\nbf_walk!(f, e, f_args; skip, skip_call)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/walks.jl:45.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.Util.bf_walk-Tuple{Any,Any,Vararg{Any,N} where N}","page":"API Documentation","title":"Main.Metatheory.Util.bf_walk","text":"Breadth First Walk (Tree Prewalk) on expressions. Does not mutate expressions.\n\n\n\nSignatures\n\nbf_walk(f::Any, e::Any, f_args::Vararg{Any,N} where N; skip, skip_call) -> Any\n\n\n\n\nMethods\n\nbf_walk(f, e, f_args; skip, skip_call)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/walks.jl:65.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.Util.binarize!-Tuple{Any,Symbol}","page":"API Documentation","title":"Main.Metatheory.Util.binarize!","text":"HARD FIX of n-arity of operators in Expr trees\n\n\n\nSignatures\n\nbinarize!(e::Any, op::Symbol) -> Any\n\n\n\n\nMethods\n\nbinarize!(e, op)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/cleaning.jl:11.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.Util.block-Tuple","page":"API Documentation","title":"Main.Metatheory.Util.block","text":"Make a block expression from an array of exprs\n\n\n\nSignatures\n\nblock(vs::Vararg{Any,N} where N) -> Any\n\n\n\n\nMethods\n\nblock(vs)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/Util.jl:20.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.Util.cleanast-Tuple{Any}","page":"API Documentation","title":"Main.Metatheory.Util.cleanast","text":"Binarize n-ary operators (+ and *) and call rmlines\n\n\n\nSignatures\n\ncleanast(ex::Any) -> Any\n\n\n\n\nMethods\n\ncleanast(ex)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/cleaning.jl:22.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.Util.df_walk!-Tuple{Any,Any,Vararg{Any,N} where N}","page":"API Documentation","title":"Main.Metatheory.Util.df_walk!","text":"Depth First Walk (Tree Postwalk) on expressions, mutates expression in-place.\n\n\n\nSignatures\n\ndf_walk!(f::Any, e::Any, f_args::Vararg{Any,N} where N; skip, skip_call) -> Any\n\n\n\n\nMethods\n\ndf_walk!(f, e, f_args; skip, skip_call)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/walks.jl:4.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.Util.df_walk-Tuple{Any,Any,Vararg{Any,N} where N}","page":"API Documentation","title":"Main.Metatheory.Util.df_walk","text":"Depth First Walk (Tree Postwalk) on expressions. Does not mutate expressions.\n\n\n\nSignatures\n\ndf_walk(f::Any, e::Any, f_args::Vararg{Any,N} where N; skip, skip_call) -> Any\n\n\n\n\nMethods\n\ndf_walk(f, e, f_args; skip, skip_call)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/walks.jl:22.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.Util.dollar-Tuple{Any}","page":"API Documentation","title":"Main.Metatheory.Util.dollar","text":"Add a dollar expression\n\n\n\nSignatures\n\ndollar(v::Any) -> Expr\n\n\n\n\nMethods\n\ndollar(v)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/Util.jl:18.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.Util.normalize-Tuple{Any,Any,Vararg{Any,N} where N}","page":"API Documentation","title":"Main.Metatheory.Util.normalize","text":"Iterates a function f on datum until a fixed point is reached where f(x) == x\n\n\n\nSignatures\n\nnormalize(f::Any, datum::Any, fargs::Vararg{Any,N} where N; callback) -> Any\n\n\n\n\nMethods\n\nnormalize(f, datum, fargs; callback)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/fixpoint.jl:4.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.Util.normalize_nocycle-Tuple{Any,Any,Vararg{Any,N} where N}","page":"API Documentation","title":"Main.Metatheory.Util.normalize_nocycle","text":"Like normalize but keeps a vector of hashes to detect cycles, returns the current datum when a cycle is detected\n\n\n\nSignatures\n\nnormalize_nocycle(f::Any, datum::Any, fargs::Vararg{Any,N} where N; callback) -> Any\n\n\n\n\nMethods\n\nnormalize_nocycle(f, datum, fargs; callback)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/fixpoint.jl:20.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.Util.rmlines-Tuple{Expr}","page":"API Documentation","title":"Main.Metatheory.Util.rmlines","text":"Remove LineNumberNode from quoted blocks of code\n\n\n\nSignatures\n\nrmlines(e::Expr) -> Any\n\n\n\n\nMethods\n\nrmlines(e)\n\ndefined at /home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/cleaning.jl:5.\n\n\n\n\n\n","category":"method"},{"location":"#Metatheory.jl","page":"Metatheory.jl","title":"Metatheory.jl","text":"","category":"section"},{"location":"","page":"Metatheory.jl","title":"Metatheory.jl","text":"<p align=\"center\">\n<img width=\"400px\" src=\"https://raw.githubusercontent.com/0x0f0f0f/Metatheory.jl/master/docs/src/assets/dragon.jpg\"/>\n</p>","category":"page"},{"location":"","page":"Metatheory.jl","title":"Metatheory.jl","text":"Metatheory.jl is a general purpose metaprogramming and algebraic computation library for the Julia programming language, designed to take advantage of the powerful reflection capabilities to bridge the gap between symbolic mathematics, abstract interpretation, equational reasoning, optimization, composable compiler transforms, and advanced homoiconic pattern matching features.","category":"page"},{"location":"","page":"Metatheory.jl","title":"Metatheory.jl","text":"Read the preprint on arXiv.","category":"page"}]
}
