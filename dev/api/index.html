<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Documentation Â· Metatheory.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Metatheory.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Metatheory.jl</a></li><li><a class="tocitem" href="../theories/">Rules and Theories Syntax</a></li><li><a class="tocitem" href="../egraphs/">EGraphs and Equality Saturation</a></li><li><a class="tocitem" href="../analysis/">EGraph Analyses and Extraction</a></li><li><a class="tocitem" href="../classic/">Classical Rewriting</a></li><li class="is-active"><a class="tocitem" href>API Documentation</a><ul class="internal"><li><a class="tocitem" href="#Metatheory"><span>Metatheory</span></a></li><li><a class="tocitem" href="#Metatheory.EGraphs"><span>Metatheory.EGraphs</span></a></li><li><a class="tocitem" href="#Metatheory.EGraphs.Schedulers"><span>Metatheory.EGraphs.Schedulers</span></a></li><li><a class="tocitem" href="#Metatheory.Util"><span>Metatheory.Util</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab">ï‚›</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Documentation"><a class="docs-heading-anchor" href="#API-Documentation">API Documentation</a><a id="API-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#API-Documentation" title="Permalink"></a></h1><h2 id="Metatheory"><a class="docs-heading-anchor" href="#Metatheory">Metatheory</a><a id="Metatheory-1"></a><a class="docs-heading-anchor-permalink" href="#Metatheory" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.Theory" href="#Main.Metatheory.Theory"><code>Main.Metatheory.Theory</code></a> â€” <span class="docstring-category">Type</span></header><section><div><p>A Theory is either a vector of <a href="#Main.Metatheory.Rule-Tuple{Expr}"><code>Rule</code></a> or a compiled, callable function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/theory.jl#L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.Rule-Tuple{Expr}" href="#Main.Metatheory.Rule-Tuple{Expr}"><code>Main.Metatheory.Rule</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Construct a <code>Rule</code> from a quoted expression. You can also use the [<code>@rule</code>] macro to create a <code>Rule</code>.</p><p><strong>Symbolic Rules</strong></p><p>Rules defined as <code>left_hand =&gt; right_hand</code> are called <code>symbolic</code> rules. Application of a <code>symbolic</code> Rule is a replacement of the <code>left_hand</code> pattern with the <code>right_hand</code> substitution, with the correct instantiation of pattern variables. Function call symbols are not treated as pattern variables, all other identifiers are treated as pattern variables. Literals such as <code>5, :e, &quot;hello&quot;</code> are not treated as pattern variables.</p><p><strong>Dynamic Rules</strong></p><p>Rules defined as <code>left_hand |&gt; right_hand</code> are called <code>dynamic</code> rules. Dynamic rules behave like anonymous functions. Instead of a symbolic substitution, the right hand of a dynamic <code>|&gt;</code> rule is evaluated during rewriting: matched values are bound to pattern variables as in a regular function call. This allows for dynamic computation of</p><p><strong>Type Assertions</strong></p><p>Type assertions are supported in the left hand of rules to match and access literal values both when using classic rewriting and EGraph based rewriting. To use a type assertion pattern, add <code>::T</code> after a pattern variable in the <code>left_hand</code> of a rule.</p><hr/><p><strong>Examples</strong></p><p>Symbolic rule</p><pre><code class="language-julia">Rule(:(a * b =&gt; b * a))</code></pre><pre><code class="language-julia">Rule(:(a::Number * b::Number |&gt; a*b))</code></pre><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">Rule(e::Expr; mod) -&gt; Main.Metatheory.Rule
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">Rule(e; mod)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/rule.jl#L66"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/rule.jl:66</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/rule.jl#L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.compile_theory-Tuple{Array{Main.Metatheory.Rule,1},Module}" href="#Main.Metatheory.compile_theory-Tuple{Array{Main.Metatheory.Rule,1},Module}"><code>Main.Metatheory.compile_theory</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Compile a theory to a closure that does the pattern matching job Returns a RuntimeGeneratedFunction, which does not use eval and is as fast as a regular Julia anonymous function ðŸ”¥</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">compile_theory(theory::Array{Main.Metatheory.Rule,1}, mod::Module; __source__) -&gt; RuntimeGeneratedFunctions.RuntimeGeneratedFunction{_A,_B,_C,_D} where _D where _C where _B where _A
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">compile_theory(theory, mod; __source__)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/matchcore_compiler.jl#L77"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/matchcore_compiler.jl:77</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/matchcore_compiler.jl#L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.eval_types_in_assertions-Tuple{Any,Module}" href="#Main.Metatheory.eval_types_in_assertions-Tuple{Any,Module}"><code>Main.Metatheory.eval_types_in_assertions</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>When creating a theory, type assertions in the left hand contain symbols. We want to replace the type symbols with the real type values, to fully support the subtyping mechanism during pattern matching.</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">eval_types_in_assertions(x::Any, mod::Module) -&gt; Any
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">eval_types_in_assertions(x, mod)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/rule.jl#L126"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/rule.jl:126</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/rule.jl#L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.genrhsfun-Tuple{Any,Any,Module}" href="#Main.Metatheory.genrhsfun-Tuple{Any,Any,Module}"><code>Main.Metatheory.genrhsfun</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Generates a tuple containing the list of formal parameters (<code>Symbol</code>s) and the <a href="@ref"><code>RuntimeGeneratedFunction</code></a> corresponding to the right hand side of a <code>:dynamic</code> <a href="#Main.Metatheory.Rule-Tuple{Expr}"><code>Rule</code></a>.</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">genrhsfun(left::Any, right::Any, mod::Module) -&gt; Tuple{Array{Symbol,1},RuntimeGeneratedFunctions.RuntimeGeneratedFunction{_A,_B,_C,_D} where _D where _C where _B where _A}
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">genrhsfun(left, right, mod)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/rule.jl#L106"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/rule.jl:106</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/rule.jl#L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.rewrite-Tuple{Any,Union{Array{Main.Metatheory.Rule,1}, Function}}" href="#Main.Metatheory.rewrite-Tuple{Any,Union{Array{Main.Metatheory.Rule,1}, Function}}"><code>Main.Metatheory.rewrite</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>This function executes a classical rewriting algorithm on a Julia expression <code>ex</code>. Classical rewriting applies rule in order with a fixed point iteration:</p><p>This algorithm heavily relies on <a href="https://github.com/SciML/RuntimeGeneratedFunctions.jl">RuntimeGeneratedFunctions.jl</a> and the <a href="https://github.com/SciML/RuntimeGeneratedFunctions.jl">MatchCore</a> pattern matcher. <strong>NOTE</strong>: this does not involve the use of <a href="#Main.Metatheory.EGraphs.EGraph"><code>EGraphs.EGraph</code></a> or equality saturation (<a href="#Main.Metatheory.EGraphs.saturate!-Tuple{Main.Metatheory.EGraphs.EGraph,Array{Main.Metatheory.Rule,1}}"><code>EGraphs.saturate!</code></a>). When using <code>rewrite</code>, be aware of infinite loops: Since rules are matched in order in every iteration, it is possible that commonly used symbolic rules such as commutativity or associativity of operators may cause this algorithm to have a cycling computation instantly. This algorithm detects cycling computation by keeping an history of hashes, and instantly returns when a cycle is detected.</p><p>This algorithm is suitable for simple, deterministic symbolic rewrites. For more advanced use cases, where it is needed to apply multiple rewrites at the same time, or it is known that rules are causing loops, please use <a href="#Main.Metatheory.EGraphs.EGraph"><code>EGraphs.EGraph</code></a> and equality saturation (<a href="#Main.Metatheory.EGraphs.saturate!-Tuple{Main.Metatheory.EGraphs.EGraph,Array{Main.Metatheory.Rule,1}}"><code>EGraphs.saturate!</code></a>).</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">rewrite(ex::Any, theory::Union{Array{Main.Metatheory.Rule,1}, Function}; __source__, order, m, timeout) -&gt; Any
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">rewrite(ex, theory; __source__, order, m, timeout)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/rewrite.jl#L28"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/rewrite.jl:28</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/rewrite.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.@compile_theory-Tuple{Any}" href="#Main.Metatheory.@compile_theory-Tuple{Any}"><code>Main.Metatheory.@compile_theory</code></a> â€” <span class="docstring-category">Macro</span></header><section><div><p>Compile a theory at runtime to a closure that does the pattern matching job</p><hr/><p><strong>Signatures</strong></p><hr/><p><strong>Methods</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/matchcore_compiler.jl#L89">source</a></section></article><h2 id="Metatheory.EGraphs"><a class="docs-heading-anchor" href="#Metatheory.EGraphs">Metatheory.EGraphs</a><a id="Metatheory.EGraphs-1"></a><a class="docs-heading-anchor-permalink" href="#Metatheory.EGraphs" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.EGraphs.AbstractAnalysis" href="#Main.Metatheory.EGraphs.AbstractAnalysis"><code>Main.Metatheory.EGraphs.AbstractAnalysis</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractAnalysis</code></pre><p>Abstract type representing an <a href="#Main.Metatheory.EGraphs.EGraph"><code>EGraph</code></a> analysis, attaching values from a join semi-lattice domain to an EGraph</p><hr/><p><strong>Fields</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/EGraphs/egg.jl#L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.EGraphs.EGraph" href="#Main.Metatheory.EGraphs.EGraph"><code>Main.Metatheory.EGraphs.EGraph</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct EGraph</code></pre><p>A concrete type representing an [<code>EGraph</code>]. See the <a href="https://dl.acm.org/doi/pdf/10.1145/3434304">egg paper</a> for implementation details</p><hr/><p><strong>Fields</strong></p><ul><li><p><code>U::DataStructures.IntDisjointSets</code></p><p>stores the equality relations over e-class ids</p></li><li><p><code>M::Dict{Int64,Array{Any,1}}</code></p><p>map from eclass id to eclasses</p></li><li><p><code>H::Dict{Any,Int64}</code></p></li><li><p><code>parents::Dict{Int64,Array{Tuple{Any,Int64},1}}</code></p></li><li><p><code>dirty::Array{Int64,1}</code></p><p>worklist for ammortized upwards merging</p></li><li><p><code>root::Int64</code></p></li><li><p><code>analyses::Array{Main.Metatheory.EGraphs.AbstractAnalysis,1}</code></p><p>A vector of analyses associated to the EGraph</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/EGraphs/egg.jl#L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.EGraphs.ExtractionAnalysis" href="#Main.Metatheory.EGraphs.ExtractionAnalysis"><code>Main.Metatheory.EGraphs.ExtractionAnalysis</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ExtractionAnalysis &lt;: Main.Metatheory.EGraphs.AbstractAnalysis</code></pre><p>An <a href="#Main.Metatheory.EGraphs.AbstractAnalysis"><code>AbstractAnalysis</code></a> that computes the cost of expression nodes and chooses the node with the smallest cost for each E-Class.</p><hr/><p><strong>Fields</strong></p><ul><li><p><code>egraph::Main.Metatheory.EGraphs.EGraph</code></p></li><li><p><code>costfun::Function</code></p></li><li><p><code>data::Dict{Int64,Tuple{Any,Number}}</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/EGraphs/extraction.jl#L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.merge!-Tuple{Main.Metatheory.EGraphs.EGraph,Int64,Int64}" href="#Base.merge!-Tuple{Main.Metatheory.EGraphs.EGraph,Int64,Int64}"><code>Base.merge!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Given an <a href="#Main.Metatheory.EGraphs.EGraph"><code>EGraph</code></a> and two e-class ids, set the two e-classes as equal.</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">merge!(G::Main.Metatheory.EGraphs.EGraph, a::Int64, b::Int64) -&gt; Int64
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">merge!(G, a, b)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/EGraphs/egg.jl#L117"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egg.jl:117</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/EGraphs/egg.jl#L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.EGraphs.add!-Tuple{Main.Metatheory.EGraphs.EGraph,Any}" href="#Main.Metatheory.EGraphs.add!-Tuple{Main.Metatheory.EGraphs.EGraph,Any}"><code>Main.Metatheory.EGraphs.add!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Inserts an e-node in an <a href="#Main.Metatheory.EGraphs.EGraph"><code>EGraph</code></a></p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">add!(G::Main.Metatheory.EGraphs.EGraph, n::Any) -&gt; Main.Metatheory.EGraphs.EClass
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">add!(G, n)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/EGraphs/egg.jl#L68"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egg.jl:68</code></a>.</p><pre><code class="language-julia">add!(g, c)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/EGraphs/egg.jl#L92"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egg.jl:92</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/EGraphs/egg.jl#L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.EGraphs.addanalysis!-Tuple{Main.Metatheory.EGraphs.EGraph,Type{var&quot;#s4&quot;} where var&quot;#s4&quot;&lt;:Main.Metatheory.EGraphs.AbstractAnalysis,Vararg{Any,N} where N}" href="#Main.Metatheory.EGraphs.addanalysis!-Tuple{Main.Metatheory.EGraphs.EGraph,Type{var&quot;#s4&quot;} where var&quot;#s4&quot;&lt;:Main.Metatheory.EGraphs.AbstractAnalysis,Vararg{Any,N} where N}"><code>Main.Metatheory.EGraphs.addanalysis!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Adds an <a href="#Main.Metatheory.EGraphs.AbstractAnalysis"><code>AbstractAnalysis</code></a> to an <a href="#Main.Metatheory.EGraphs.EGraph"><code>EGraph</code></a>. An <a href="#Main.Metatheory.EGraphs.EGraph"><code>EGraph</code></a> can only contain one analysis of type <code>AnType</code>.</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">addanalysis!(g::Main.Metatheory.EGraphs.EGraph, AnType::Type{var&quot;#s4&quot;} where var&quot;#s4&quot;&lt;:Main.Metatheory.EGraphs.AbstractAnalysis, args::Vararg{Any,N} where N; lazy) -&gt; Any
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">addanalysis!(g, AnType, args; lazy)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/EGraphs/analysis.jl#L6"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/analysis.jl:6</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/EGraphs/analysis.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.EGraphs.addexpr!-Tuple{Main.Metatheory.EGraphs.EGraph,Any}" href="#Main.Metatheory.EGraphs.addexpr!-Tuple{Main.Metatheory.EGraphs.EGraph,Any}"><code>Main.Metatheory.EGraphs.addexpr!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Recursively traverse an <a href="@ref"><code>Expr</code></a> and insert terms into an <a href="#Main.Metatheory.EGraphs.EGraph"><code>EGraph</code></a>. If <code>e</code> is not an <a href="@ref"><code>Expr</code></a>, then directly insert the literal into the <a href="#Main.Metatheory.EGraphs.EGraph"><code>EGraph</code></a>.</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">addexpr!(G::Main.Metatheory.EGraphs.EGraph, e::Any) -&gt; Main.Metatheory.EGraphs.EClass
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">addexpr!(G, e)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/EGraphs/egg.jl#L99"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egg.jl:99</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/EGraphs/egg.jl#L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.EGraphs.analyze!-Tuple{Main.Metatheory.EGraphs.EGraph,Main.Metatheory.EGraphs.AbstractAnalysis,Array{Int64,1}}" href="#Main.Metatheory.EGraphs.analyze!-Tuple{Main.Metatheory.EGraphs.EGraph,Main.Metatheory.EGraphs.AbstractAnalysis,Array{Int64,1}}"><code>Main.Metatheory.EGraphs.analyze!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p><strong>WARNING</strong>. This function is unstable.</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">analyze!(g::Main.Metatheory.EGraphs.EGraph, analysis::Main.Metatheory.EGraphs.AbstractAnalysis, ids::Array{Int64,1}) -&gt; Main.Metatheory.EGraphs.AbstractAnalysis
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">analyze!(g, analysis, ids)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/EGraphs/analysis.jl#L22"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/analysis.jl:22</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/EGraphs/analysis.jl#L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.EGraphs.astsize-Tuple{Any}" href="#Main.Metatheory.EGraphs.astsize-Tuple{Any}"><code>Main.Metatheory.EGraphs.astsize</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>A basic cost function, where the computed cost is the size (number of children) of the current expression.</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">astsize(n::Any) -&gt; Int64
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">astsize(n)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/EGraphs/extraction.jl#L5"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/extraction.jl:5</code></a>.</p><pre><code class="language-julia">astsize(n)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/EGraphs/extraction.jl#L6"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/extraction.jl:6</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/EGraphs/extraction.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.EGraphs.astsize_inv-Tuple{Any}" href="#Main.Metatheory.EGraphs.astsize_inv-Tuple{Any}"><code>Main.Metatheory.EGraphs.astsize_inv</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>A basic cost function, where the computed cost is the size (number of children) of the current expression, times -1. Strives to get the largest expression</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">astsize_inv(n::Any) -&gt; Int64
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">astsize_inv(n)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/EGraphs/extraction.jl#L13"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/extraction.jl:13</code></a>.</p><pre><code class="language-julia">astsize_inv(n)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/EGraphs/extraction.jl#L14"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/extraction.jl:14</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/EGraphs/extraction.jl#L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.EGraphs.ematchlist-Tuple{Main.Metatheory.EGraphs.EGraph,Array{Any,1},Array{Int64,1},Base.ImmutableDict{Any,Tuple{Main.Metatheory.EGraphs.EClass,Any}}}" href="#Main.Metatheory.EGraphs.ematchlist-Tuple{Main.Metatheory.EGraphs.EGraph,Array{Any,1},Array{Int64,1},Base.ImmutableDict{Any,Tuple{Main.Metatheory.EGraphs.EClass,Any}}}"><code>Main.Metatheory.EGraphs.ematchlist</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>From <a href="https://www.hpl.hp.com/techreports/2003/HPL-2003-148.pdf">https://www.hpl.hp.com/techreports/2003/HPL-2003-148.pdf</a> The iterator <code>ematchlist</code> matches a list of terms <code>t</code> to a list of E-nodes by first finding all substitutions that match the first term to the first E-node, and then extending each such substitution in all possible ways that match the remaining terms to the remaining E-nodes. The base case of this recursion is the empty list, which requires no extension to the substitution; the other case relies on Match to find the substitutions that match the first term to the first E-node.</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">ematchlist(e::Main.Metatheory.EGraphs.EGraph, t::Array{Any,1}, v::Array{Int64,1}, sub::Base.ImmutableDict{Any,Tuple{Main.Metatheory.EGraphs.EClass,Any}}) -&gt; Array{Base.ImmutableDict{Any,Tuple{Main.Metatheory.EGraphs.EClass,Any}},1}
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">ematchlist(e, t, v, sub)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/EGraphs/ematch.jl#L25"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/ematch.jl:25</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/EGraphs/ematch.jl#L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.EGraphs.extract!-Tuple{Main.Metatheory.EGraphs.EGraph,Main.Metatheory.EGraphs.ExtractionAnalysis}" href="#Main.Metatheory.EGraphs.extract!-Tuple{Main.Metatheory.EGraphs.EGraph,Main.Metatheory.EGraphs.ExtractionAnalysis}"><code>Main.Metatheory.EGraphs.extract!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Given an <a href="#Main.Metatheory.EGraphs.ExtractionAnalysis"><code>ExtractionAnalysis</code></a>, extract the expression with the smallest computed cost from an <a href="#Main.Metatheory.EGraphs.EGraph"><code>EGraph</code></a></p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">extract!(G::Main.Metatheory.EGraphs.EGraph, extran::Main.Metatheory.EGraphs.ExtractionAnalysis) -&gt; Any
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">extract!(G, extran)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/EGraphs/extraction.jl#L72"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/extraction.jl:72</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/EGraphs/extraction.jl#L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.EGraphs.find-Tuple{Main.Metatheory.EGraphs.EGraph,Int64}" href="#Main.Metatheory.EGraphs.find-Tuple{Main.Metatheory.EGraphs.EGraph,Int64}"><code>Main.Metatheory.EGraphs.find</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Returns the canonical e-class id for a given e-class.</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">find(G::Main.Metatheory.EGraphs.EGraph, a::Int64) -&gt; Int64
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">find(G, a)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/EGraphs/egg.jl#L165"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egg.jl:165</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/EGraphs/egg.jl#L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.EGraphs.isenode-Tuple{Expr}" href="#Main.Metatheory.EGraphs.isenode-Tuple{Expr}"><code>Main.Metatheory.EGraphs.isenode</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Check if an expr is an enode âŸº all args are e-classes</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">isenode(e::Expr) -&gt; Bool
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">isenode(e)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/EGraphs/enode.jl#L11"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/enode.jl:11</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/EGraphs/enode.jl#L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.EGraphs.reachable-Tuple{Main.Metatheory.EGraphs.EGraph,Int64}" href="#Main.Metatheory.EGraphs.reachable-Tuple{Main.Metatheory.EGraphs.EGraph,Int64}"><code>Main.Metatheory.EGraphs.reachable</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Recursive function that traverses an <a href="#Main.Metatheory.EGraphs.EGraph"><code>EGraph</code></a> and returns a vector of all reachable e-classes from a given e-class id.</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">reachable(g::Main.Metatheory.EGraphs.EGraph, id::Int64; hist) -&gt; Array{Int64,1}
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">reachable(g, id; hist)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/EGraphs/egg.jl#L243"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egg.jl:243</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/EGraphs/egg.jl#L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.EGraphs.rebuild!-Tuple{Main.Metatheory.EGraphs.EGraph}" href="#Main.Metatheory.EGraphs.rebuild!-Tuple{Main.Metatheory.EGraphs.EGraph}"><code>Main.Metatheory.EGraphs.rebuild!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>This function restores invariants and executes upwards merging in an <a href="#Main.Metatheory.EGraphs.EGraph"><code>EGraph</code></a>. See the <a href="https://dl.acm.org/doi/pdf/10.1145/3434304">egg paper</a> for more details.</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">rebuild!(G::Main.Metatheory.EGraphs.EGraph) -&gt; Union{Nothing, Int64}
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">rebuild!(G)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/EGraphs/egg.jl#L174"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/egg.jl:174</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/EGraphs/egg.jl#L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.EGraphs.saturate!-Tuple{Main.Metatheory.EGraphs.EGraph,Array{Main.Metatheory.Rule,1}}" href="#Main.Metatheory.EGraphs.saturate!-Tuple{Main.Metatheory.EGraphs.EGraph,Array{Main.Metatheory.Rule,1}}"><code>Main.Metatheory.EGraphs.saturate!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Given an <a href="#Main.Metatheory.EGraphs.EGraph"><code>EGraph</code></a> and a collection of rewrite rules, execute the equality saturation algorithm.</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">saturate!(egraph::Main.Metatheory.EGraphs.EGraph, theory::Array{Main.Metatheory.Rule,1}; mod, timeout, stopwhen, sizeout, scheduler) -&gt; Tuple{Bool,Main.Metatheory.EGraphs.EGraph}
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">saturate!(egraph, theory; mod, timeout, stopwhen, sizeout, scheduler)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/EGraphs/saturation.jl#L87"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/saturation.jl:87</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/EGraphs/saturation.jl#L83">source</a></section></article><h2 id="Metatheory.EGraphs.Schedulers"><a class="docs-heading-anchor" href="#Metatheory.EGraphs.Schedulers">Metatheory.EGraphs.Schedulers</a><a id="Metatheory.EGraphs.Schedulers-1"></a><a class="docs-heading-anchor-permalink" href="#Metatheory.EGraphs.Schedulers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.EGraphs.Schedulers.AbstractScheduler" href="#Main.Metatheory.EGraphs.Schedulers.AbstractScheduler"><code>Main.Metatheory.EGraphs.Schedulers.AbstractScheduler</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractScheduler</code></pre><p>Represents a rule scheduler for the equality saturation process</p><hr/><p><strong>Fields</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/EGraphs/Schedulers/abstractscheduler.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.EGraphs.Schedulers.BackoffScheduler" href="#Main.Metatheory.EGraphs.Schedulers.BackoffScheduler"><code>Main.Metatheory.EGraphs.Schedulers.BackoffScheduler</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct BackoffScheduler &lt;: Main.Metatheory.EGraphs.Schedulers.AbstractScheduler</code></pre><p>A Rewrite Scheduler that implements exponential rule backoff. For each rewrite, there exists a configurable initial match limit. If a rewrite search yield more than this limit, then we ban this rule for number of iterations, double its limit, and double the time it will be banned next time.</p><p>This seems effective at preventing explosive rules like associativity from taking an unfair amount of resources.</p><hr/><p><strong>Fields</strong></p><ul><li><p><code>data::Dict{Main.Metatheory.Rule,Main.Metatheory.EGraphs.Schedulers.BackoffSchedulerEntry}</code></p></li><li><p><code>G::Main.Metatheory.EGraphs.EGraph</code></p></li><li><p><code>theory::Array{Main.Metatheory.Rule,1}</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/EGraphs/Schedulers/backoffscheduler.jl#L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.EGraphs.Schedulers.SimpleScheduler" href="#Main.Metatheory.EGraphs.Schedulers.SimpleScheduler"><code>Main.Metatheory.EGraphs.Schedulers.SimpleScheduler</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct SimpleScheduler &lt;: Main.Metatheory.EGraphs.Schedulers.AbstractScheduler</code></pre><p>A simple Rewrite Scheduler that applies every rule every time</p><hr/><p><strong>Fields</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/EGraphs/Schedulers/simplescheduler.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.EGraphs.Schedulers.cansaturate-Tuple{Main.Metatheory.EGraphs.Schedulers.AbstractScheduler}" href="#Main.Metatheory.EGraphs.Schedulers.cansaturate-Tuple{Main.Metatheory.EGraphs.Schedulers.AbstractScheduler}"><code>Main.Metatheory.EGraphs.Schedulers.cansaturate</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Should return true if the e-graph can be said to be saturated</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">cansaturate(s::Main.Metatheory.EGraphs.Schedulers.AbstractScheduler) -&gt; Bool
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">cansaturate(s)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/EGraphs/Schedulers/abstractscheduler.jl#L12"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/abstractscheduler.jl:12</code></a>.</p><pre><code class="language-julia">cansaturate(s)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/EGraphs/Schedulers/backoffscheduler.jl#L43"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/backoffscheduler.jl:43</code></a>.</p><pre><code class="language-julia">cansaturate(s)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/EGraphs/Schedulers/simplescheduler.jl#L6"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/simplescheduler.jl:6</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/EGraphs/Schedulers/abstractscheduler.jl#L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.EGraphs.Schedulers.readstep!-Tuple{Main.Metatheory.EGraphs.Schedulers.AbstractScheduler}" href="#Main.Metatheory.EGraphs.Schedulers.readstep!-Tuple{Main.Metatheory.EGraphs.Schedulers.AbstractScheduler}"><code>Main.Metatheory.EGraphs.Schedulers.readstep!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>This function is called <strong>before</strong> pattern matching on the e-graph</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">readstep!(s::Main.Metatheory.EGraphs.Schedulers.AbstractScheduler)
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">readstep!(s)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/EGraphs/Schedulers/abstractscheduler.jl#L22"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/abstractscheduler.jl:22</code></a>.</p><pre><code class="language-julia">readstep!(s)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/EGraphs/Schedulers/backoffscheduler.jl#L45"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/backoffscheduler.jl:45</code></a>.</p><pre><code class="language-julia">readstep!(s)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/EGraphs/Schedulers/simplescheduler.jl#L13"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/simplescheduler.jl:13</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/EGraphs/Schedulers/abstractscheduler.jl#L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.EGraphs.Schedulers.shouldskip-Tuple{Main.Metatheory.EGraphs.Schedulers.AbstractScheduler,Main.Metatheory.Rule}" href="#Main.Metatheory.EGraphs.Schedulers.shouldskip-Tuple{Main.Metatheory.EGraphs.Schedulers.AbstractScheduler,Main.Metatheory.Rule}"><code>Main.Metatheory.EGraphs.Schedulers.shouldskip</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Should return true if the rule <code>r</code> should be skipped</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">shouldskip(s::Main.Metatheory.EGraphs.Schedulers.AbstractScheduler, r::Main.Metatheory.Rule) -&gt; Bool
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">shouldskip(s, r)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/EGraphs/Schedulers/abstractscheduler.jl#L17"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/abstractscheduler.jl:17</code></a>.</p><pre><code class="language-julia">shouldskip(s, r)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/EGraphs/Schedulers/backoffscheduler.jl#L27"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/backoffscheduler.jl:27</code></a>.</p><pre><code class="language-julia">shouldskip(s, r)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/EGraphs/Schedulers/simplescheduler.jl#L7"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/simplescheduler.jl:7</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/EGraphs/Schedulers/abstractscheduler.jl#L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.EGraphs.Schedulers.writestep!-Tuple{Main.Metatheory.EGraphs.Schedulers.AbstractScheduler,Main.Metatheory.Rule}" href="#Main.Metatheory.EGraphs.Schedulers.writestep!-Tuple{Main.Metatheory.EGraphs.Schedulers.AbstractScheduler,Main.Metatheory.Rule}"><code>Main.Metatheory.EGraphs.Schedulers.writestep!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>This function is called <strong>after</strong> pattern matching on the e-graph</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">writestep!(s::Main.Metatheory.EGraphs.Schedulers.AbstractScheduler, r::Main.Metatheory.Rule)
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">writestep!(s, r)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/EGraphs/Schedulers/abstractscheduler.jl#L27"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/abstractscheduler.jl:27</code></a>.</p><pre><code class="language-julia">writestep!(s, rule)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/EGraphs/Schedulers/backoffscheduler.jl#L61"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/backoffscheduler.jl:61</code></a>.</p><pre><code class="language-julia">writestep!(s, r)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/EGraphs/Schedulers/simplescheduler.jl#L14"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/EGraphs/Schedulers/simplescheduler.jl:14</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/EGraphs/Schedulers/abstractscheduler.jl#L24">source</a></section></article><h2 id="Metatheory.Util"><a class="docs-heading-anchor" href="#Metatheory.Util">Metatheory.Util</a><a id="Metatheory.Util-1"></a><a class="docs-heading-anchor-permalink" href="#Metatheory.Util" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.Util" href="#Main.Metatheory.Util"><code>Main.Metatheory.Util</code></a> â€” <span class="docstring-category">Module</span></header><section><div><p>Definitions of various utility functions for metaprogramming</p><hr/><p><strong>Imports</strong></p><ul><li><code>Base</code></li><li><code>Base.Meta</code></li><li><code>Core</code></li><li><code>DocStringExtensions</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/Util/Util.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.Util.amp-Tuple{Any}" href="#Main.Metatheory.Util.amp-Tuple{Any}"><code>Main.Metatheory.Util.amp</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Add a &amp; expression</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">amp(v::Any) -&gt; Expr
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">amp(v)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/Util/Util.jl#L22"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/Util.jl:22</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/Util/Util.jl#L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.Util.bf_walk!-Tuple{Any,Any,Vararg{Any,N} where N}" href="#Main.Metatheory.Util.bf_walk!-Tuple{Any,Any,Vararg{Any,N} where N}"><code>Main.Metatheory.Util.bf_walk!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Breadth First Walk (Tree Prewalk) on expressions mutates expression in-place.</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">bf_walk!(f::Any, e::Any, f_args::Vararg{Any,N} where N; skip, skip_call) -&gt; Any
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">bf_walk!(f, e, f_args; skip, skip_call)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/Util/walks.jl#L45"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/walks.jl:45</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/Util/walks.jl#L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.Util.bf_walk-Tuple{Any,Any,Vararg{Any,N} where N}" href="#Main.Metatheory.Util.bf_walk-Tuple{Any,Any,Vararg{Any,N} where N}"><code>Main.Metatheory.Util.bf_walk</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Breadth First Walk (Tree Prewalk) on expressions. Does not mutate expressions.</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">bf_walk(f::Any, e::Any, f_args::Vararg{Any,N} where N; skip, skip_call) -&gt; Any
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">bf_walk(f, e, f_args; skip, skip_call)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/Util/walks.jl#L65"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/walks.jl:65</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/Util/walks.jl#L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.Util.binarize!-Tuple{Any,Symbol}" href="#Main.Metatheory.Util.binarize!-Tuple{Any,Symbol}"><code>Main.Metatheory.Util.binarize!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>HARD FIX of n-arity of operators in <code>Expr</code> trees</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">binarize!(e::Any, op::Symbol) -&gt; Any
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">binarize!(e, op)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/Util/cleaning.jl#L11"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/cleaning.jl:11</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/Util/cleaning.jl#L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.Util.block-Tuple" href="#Main.Metatheory.Util.block-Tuple"><code>Main.Metatheory.Util.block</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Make a block expression from an array of exprs</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">block(vs::Vararg{Any,N} where N) -&gt; Any
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">block(vs)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/Util/Util.jl#L20"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/Util.jl:20</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/Util/Util.jl#L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.Util.cleanast-Tuple{Any}" href="#Main.Metatheory.Util.cleanast-Tuple{Any}"><code>Main.Metatheory.Util.cleanast</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Binarize n-ary operators (<code>+</code> and <code>*</code>) and call <a href="#Main.Metatheory.Util.rmlines-Tuple{Expr}"><code>rmlines</code></a></p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">cleanast(ex::Any) -&gt; Any
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">cleanast(ex)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/Util/cleaning.jl#L22"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/cleaning.jl:22</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/Util/cleaning.jl#L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.Util.df_walk!-Tuple{Any,Any,Vararg{Any,N} where N}" href="#Main.Metatheory.Util.df_walk!-Tuple{Any,Any,Vararg{Any,N} where N}"><code>Main.Metatheory.Util.df_walk!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Depth First Walk (Tree Postwalk) on expressions, mutates expression in-place.</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">df_walk!(f::Any, e::Any, f_args::Vararg{Any,N} where N; skip, skip_call) -&gt; Any
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">df_walk!(f, e, f_args; skip, skip_call)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/Util/walks.jl#L4"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/walks.jl:4</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/Util/walks.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.Util.df_walk-Tuple{Any,Any,Vararg{Any,N} where N}" href="#Main.Metatheory.Util.df_walk-Tuple{Any,Any,Vararg{Any,N} where N}"><code>Main.Metatheory.Util.df_walk</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Depth First Walk (Tree Postwalk) on expressions. Does not mutate expressions.</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">df_walk(f::Any, e::Any, f_args::Vararg{Any,N} where N; skip, skip_call) -&gt; Any
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">df_walk(f, e, f_args; skip, skip_call)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/Util/walks.jl#L22"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/walks.jl:22</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/Util/walks.jl#L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.Util.dollar-Tuple{Any}" href="#Main.Metatheory.Util.dollar-Tuple{Any}"><code>Main.Metatheory.Util.dollar</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Add a dollar expression</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">dollar(v::Any) -&gt; Expr
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">dollar(v)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/Util/Util.jl#L18"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/Util.jl:18</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/Util/Util.jl#L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.Util.normalize-Tuple{Any,Any,Vararg{Any,N} where N}" href="#Main.Metatheory.Util.normalize-Tuple{Any,Any,Vararg{Any,N} where N}"><code>Main.Metatheory.Util.normalize</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Iterates a function <code>f</code> on <code>datum</code> until a fixed point is reached where <code>f(x) == x</code></p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">normalize(f::Any, datum::Any, fargs::Vararg{Any,N} where N; callback) -&gt; Any
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">normalize(f, datum, fargs; callback)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/Util/fixpoint.jl#L4"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/fixpoint.jl:4</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/Util/fixpoint.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.Util.normalize_nocycle-Tuple{Any,Any,Vararg{Any,N} where N}" href="#Main.Metatheory.Util.normalize_nocycle-Tuple{Any,Any,Vararg{Any,N} where N}"><code>Main.Metatheory.Util.normalize_nocycle</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Like <a href="#Main.Metatheory.Util.normalize-Tuple{Any,Any,Vararg{Any,N} where N}"><code>normalize</code></a> but keeps a vector of hashes to detect cycles, returns the current datum when a cycle is detected</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">normalize_nocycle(f::Any, datum::Any, fargs::Vararg{Any,N} where N; callback) -&gt; Any
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">normalize_nocycle(f, datum, fargs; callback)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/Util/fixpoint.jl#L20"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/fixpoint.jl:20</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/Util/fixpoint.jl#L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.Metatheory.Util.rmlines-Tuple{Expr}" href="#Main.Metatheory.Util.rmlines-Tuple{Expr}"><code>Main.Metatheory.Util.rmlines</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Remove LineNumberNode from quoted blocks of code</p><hr/><p><strong>Signatures</strong></p><pre><code class="language-julia">rmlines(e::Expr) -&gt; Any
</code></pre><hr/><p><strong>Methods</strong></p><pre><code class="language-julia">rmlines(e)</code></pre><p>defined at <a href="https://github.com/0x0f0f0f/Metatheory.jl/tree/60c30f006113998c75215bb7eb166512c8034890//src/Util/cleaning.jl#L5"><code>/home/runner/work/Metatheory.jl/Metatheory.jl/src/Util/cleaning.jl:5</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/0x0f0f0f/Metatheory.jl/blob/60c30f006113998c75215bb7eb166512c8034890/src/Util/cleaning.jl#L2">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../classic/">Â« Classical Rewriting</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 5 March 2021 09:18">Friday 5 March 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
