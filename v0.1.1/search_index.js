var documenterSearchIndex = {"docs":
[{"location":"api/#API-Documentation","page":"API Documentation","title":"API Documentation","text":"","category":"section"},{"location":"api/#Metatheory","page":"API Documentation","title":"Metatheory","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Modules = [Metatheory]","category":"page"},{"location":"api/#Main.Metatheory.Rule","page":"API Documentation","title":"Main.Metatheory.Rule","text":"Structure representing rewrite rules.\n\n\n\n\n\n","category":"type"},{"location":"api/#Main.Metatheory.compile_theory-Tuple{Array{Main.Metatheory.Rule,1},Module}","page":"API Documentation","title":"Main.Metatheory.compile_theory","text":"Compile a theory to a closure that does the pattern matching job Returns a RuntimeGeneratedFunction, which does not use eval and is as fast as a regular Julia anonymous function ðŸ”¥\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.@compile_theory-Tuple{Any}","page":"API Documentation","title":"Main.Metatheory.@compile_theory","text":"Compile a theory at runtime to a closure that does the pattern matching job\n\n\n\n\n\n","category":"macro"},{"location":"api/#Metatheory.EGraphs","page":"API Documentation","title":"Metatheory.EGraphs","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"CurrentModule = Metatheory\nDocTestSetup  = quote\n    using Metatheory\nend","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Modules = [Metatheory.EGraphs]","category":"page"},{"location":"api/#Main.Metatheory.EGraphs.RhsFunCache","page":"API Documentation","title":"Main.Metatheory.EGraphs.RhsFunCache","text":"Type representing a cache of RuntimeGeneratedFunctions corresponding to right hand sides of dynamic rules\n\n\n\n\n\n","category":"type"},{"location":"api/#Main.Metatheory.EGraphs.eval_types_in_assertions-Tuple{Any,Module}","page":"API Documentation","title":"Main.Metatheory.EGraphs.eval_types_in_assertions","text":"When creating a theory, type assertions in the left hand contain symbols. We want to replace the type symbols with the real type values, to fully support the subtyping mechanism during pattern matching.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.EGraphs.genrhsfun-Tuple{Main.Metatheory.Rule,Module}","page":"API Documentation","title":"Main.Metatheory.EGraphs.genrhsfun","text":"Generates a tuple containing the list of formal parameters (Symbols) and the RuntimeGeneratedFunction corresponding to the right hand side of a :dynamic Rule.\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.EGraphs.Schedulers","page":"API Documentation","title":"Metatheory.EGraphs.Schedulers","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"CurrentModule = Metatheory\nDocTestSetup  = quote\n    using Metatheory\nend","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Modules = [Metatheory.EGraphs.Schedulers]","category":"page"},{"location":"api/#Main.Metatheory.EGraphs.Schedulers.AbstractScheduler","page":"API Documentation","title":"Main.Metatheory.EGraphs.Schedulers.AbstractScheduler","text":"Represents a rule scheduler for the equality saturation process\n\n\n\n\n\n","category":"type"},{"location":"api/#Main.Metatheory.EGraphs.Schedulers.BackoffScheduler","page":"API Documentation","title":"Main.Metatheory.EGraphs.Schedulers.BackoffScheduler","text":"A Rewrite Scheduler that implements exponential rule backoff. For each rewrite, there exists a configurable initial match limit. If a rewrite search yield more than this limit, then we ban this rule for number of iterations, double its limit, and double the time it will be banned next time.\n\nThis seems effective at preventing explosive rules like associativity from taking an unfair amount of resources.\n\n\n\n\n\n","category":"type"},{"location":"api/#Main.Metatheory.EGraphs.Schedulers.SimpleScheduler","page":"API Documentation","title":"Main.Metatheory.EGraphs.Schedulers.SimpleScheduler","text":"A simple Rewrite Scheduler that applies every rule every time\n\n\n\n\n\n","category":"type"},{"location":"api/#Main.Metatheory.EGraphs.Schedulers.cansaturate-Tuple{Main.Metatheory.EGraphs.Schedulers.AbstractScheduler}","page":"API Documentation","title":"Main.Metatheory.EGraphs.Schedulers.cansaturate","text":"Should return true if the e-graph can be said to be saturated\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.EGraphs.Schedulers.readstep!-Tuple{Main.Metatheory.EGraphs.Schedulers.AbstractScheduler}","page":"API Documentation","title":"Main.Metatheory.EGraphs.Schedulers.readstep!","text":"This function is called before pattern matching on the e-graph\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.EGraphs.Schedulers.shouldskip-Tuple{Main.Metatheory.EGraphs.Schedulers.AbstractScheduler,Main.Metatheory.Rule}","page":"API Documentation","title":"Main.Metatheory.EGraphs.Schedulers.shouldskip","text":"Should return true if the rule r should be skipped\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.EGraphs.Schedulers.writestep!-Tuple{Main.Metatheory.EGraphs.Schedulers.AbstractScheduler,Main.Metatheory.Rule}","page":"API Documentation","title":"Main.Metatheory.EGraphs.Schedulers.writestep!","text":"This function is called after pattern matching on the e-graph\n\n\n\n\n\n","category":"method"},{"location":"api/#Metatheory.Util","page":"API Documentation","title":"Metatheory.Util","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"CurrentModule = Metatheory\nDocTestSetup  = quote\n    using Metatheory\nend","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Modules = [Util]","category":"page"},{"location":"api/#Main.Metatheory.Util","page":"API Documentation","title":"Main.Metatheory.Util","text":"Definitions of various utility functions for metaprogramming\n\n\n\n\n\n","category":"module"},{"location":"api/#Main.Metatheory.Util.amp-Tuple{Any}","page":"API Documentation","title":"Main.Metatheory.Util.amp","text":"Add a & expression\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.Util.bf_walk!-Tuple{Any,Any,Vararg{Any,N} where N}","page":"API Documentation","title":"Main.Metatheory.Util.bf_walk!","text":"Breadth First Walk (Tree Prewalk) on expressions mutates expression in-place.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.Util.bf_walk-Tuple{Any,Any,Vararg{Any,N} where N}","page":"API Documentation","title":"Main.Metatheory.Util.bf_walk","text":"Breadth First Walk (Tree Prewalk) on expressions. Does not mutate expressions.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.Util.binarize!-Tuple{Any,Symbol}","page":"API Documentation","title":"Main.Metatheory.Util.binarize!","text":"HARD FIX of n-arity of operators in Expr trees\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.Util.block-Tuple","page":"API Documentation","title":"Main.Metatheory.Util.block","text":"Make a block expression from an array of exprs\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.Util.cleanast-Tuple{Any}","page":"API Documentation","title":"Main.Metatheory.Util.cleanast","text":"Binarize n-ary operators (+ and *) and call rmlines\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.Util.df_walk!-Tuple{Any,Any,Vararg{Any,N} where N}","page":"API Documentation","title":"Main.Metatheory.Util.df_walk!","text":"Depth First Walk (Tree Postwalk) on expressions, mutates expression in-place.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.Util.df_walk-Tuple{Any,Any,Vararg{Any,N} where N}","page":"API Documentation","title":"Main.Metatheory.Util.df_walk","text":"Depth First Walk (Tree Postwalk) on expressions. Does not mutate expressions.\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.Util.dollar-Tuple{Any}","page":"API Documentation","title":"Main.Metatheory.Util.dollar","text":"Add a dollar expression\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.Util.normalize-Tuple{Any,Any,Vararg{Any,N} where N}","page":"API Documentation","title":"Main.Metatheory.Util.normalize","text":"Iterates a function f on datum until a fixed point is reached where f(x) == x\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.Util.normalize_nocycle-Tuple{Any,Any,Vararg{Any,N} where N}","page":"API Documentation","title":"Main.Metatheory.Util.normalize_nocycle","text":"Like normalize but keeps a vector of hashes to detect cycles, returns the current datum when a cycle is detected\n\n\n\n\n\n","category":"method"},{"location":"api/#Main.Metatheory.Util.rmlines-Tuple{Expr}","page":"API Documentation","title":"Main.Metatheory.Util.rmlines","text":"Remove LineNumberNode from quoted blocks of code\n\n\n\n\n\n","category":"method"},{"location":"#Metatheory.jl","page":"Metatheory.jl","title":"Metatheory.jl","text":"","category":"section"},{"location":"","page":"Metatheory.jl","title":"Metatheory.jl","text":"<p align=\"center\">\n<img width=\"400px\" src=\"https://raw.githubusercontent.com/0x0f0f0f/Metatheory.jl/master/docs/src/assets/dragon.jpg\"/>\n</p>","category":"page"},{"location":"","page":"Metatheory.jl","title":"Metatheory.jl","text":"Metatheory.jl is a general purpose metaprogramming and algebraic computation library for the Julia programming language, designed to take advantage of the powerful reflection capabilities to bridge the gap between symbolic mathematics, abstract interpretation, equational reasoning, optimization, composable compiler transforms, and advanced homoiconic pattern matching features.","category":"page"},{"location":"","page":"Metatheory.jl","title":"Metatheory.jl","text":"Read the preprint on arXiv.","category":"page"}]
}
